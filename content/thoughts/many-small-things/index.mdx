---
title: Many Small Things
description: >-
  A comparison of big things and small things where we think about dependencies, code composition, and how we can
  re-think our code to be reusable.
date: 2019-04-10
author: Kyle Thompson
bannerImage: ./images/banner.jpg
bannerCredit: _Photo by [Hans-Peter Gauster](https://unsplash.com/photos/3y1zF4hIPCg)_
bannerAlt: Many small puzzle pieces
categories: []
keywords: []
published: true
---

import Link from '../../shared/components/external-link';

Recently at work, I've had a lot of time to think about how we architect and design our server in a way that will scale
for our current needs and future ventures. While doing that, I feel like I keep coming back to a few small, guiding
ideas that I'm planning on writing about. To start out the mini-series, let's talk about big things and small things.

Before getting right into it, though, I thought it might be good to give a bit of an overview of why I'm thinking about
it at all.

# Why is this important to me?

At <Link href="https://root.engineering/">Root</Link>, I'm currently an engineer on two teams: Application
Infrastructure (not quite what it sounds like) and New Products/Product Variants.

At first read, that doesn't sound entirely related, but it might make more sense after hearing a bit about what we do on
those teams.

On the Application Infrastructure team, we're responsible for the overall architectural direction of our backend and
client codebases as well as developer productivity and the tools around that. On the New Products/ Product Variants
team, we're responsible for building out new products or varying our existing ones (aptly named, right?) and making sure
we can scale that while growing out both horizontally and vertically.

Insurance is an _extremely_ complex domain to work in, so while "building out new products and varying existing ones"
might sound straight-forward, there are a ton of product and state specific domain requirements that we need to build
out and maintain while we expand to every state. Given that background, it kinda makes sense to have a bit of overlap
between those teams since there will naturally be architectural concerns while trying to build out entire new offerings
or new flavors of existing ones.

Like any other complex system, we need to be pretty careful about how we write our code to make sure new engineers can
efficiently onboard and make meaningful contributions without understanding the entire application. Additionally, we
need to make sure that we aren't constraining ourselves so that our longer-tenured employees feel like they're limited
and unable to properly build the features they need to.

# The Problem

In insurance, we have a lot of moving pieces. At a high level, going from zero to policyholder looks something like
this:

1. Collect account information (email/password)
1. Collect profile information (address, license numbers, VINs, etc.)
1. Use that information to fetch reports from external services
1. Record the test drive
1. Use the profile information, reports, and driving data to figure out what to charge
1. Decide on a set of coverages to get a quote
1. Purchase the policy

There's a lot of insurance-specific stuff in there, but you can probably see a few pieces at least: accounts, profiles,
reports, test drive, rating, quotes, and policies. Even ignoring the rest of our domain, you can see how things might
get unwieldy pretty fast.

An initial attempt at modeling this might look something like this:

```ruby
class Policy < ApplicationRecord
  belongs_to :quote
end

class Quote < ApplicationRecord
  belongs_to :rate
  has_many :coverages
end

class Rate < ApplicationRecord
  belongs_to :profile
  has_many :drivers, through: :profile
  has_many :driving_data, through: :drivers
  has_many :rate_reports
  has_many :reports, through: :rate_reports
end

class DrivingData < ApplicationRecord
  belongs_to :driver
end

class Report < ApplicationRecord
  belongs_to :profile
end

class Profile < ApplicationRecord
  belongs_to :account
  has_many :drivers
end
```

In this example, you can see below that each step in the process knows about the step before. Since it has that
knowledge and a hard dependency on it, we end up with a really tall dependency graph.

```ruby {2,6,11,19,23,27}
class Policy < ApplicationRecord
  belongs_to :quote
end

class Quote < ApplicationRecord
  belongs_to :rate
  has_many :coverages
end

class Rate < ApplicationRecord
  belongs_to :profile
  has_many :drivers, through: :profile
  has_many :driving_data, through: :drivers
  has_many :rate_reports
  has_many :reports, through: :rate_reports
end

class DrivingData < ApplicationRecord
  belongs_to :driver
end

class Report < ApplicationRecord
  belongs_to :profile
end

class Profile < ApplicationRecord
  belongs_to :account
  has_many :drivers
end
```

While we do have some small things at the bottom of the stack (like the profile and account), we also have a
really-big-thing at the very top of the stack.

In a lot of cases, this might not be a big deal (and we definitely should avoid overcomplicating the code if that is the
case). That being said, in a sufficiently complex domain like ours, you'll probably run into some problems. Off the top
of my head, here are a few:

- When one unrelated thing at the bottom changes, everything above it can break
- Setting up tests becomes cumbersome and slow (to create a policy, you'll need everything below it)
- Pieces at the top of the stack know about _everything_
- New functionality can (for the most part) only scale vertically by adding to the top of the stack

# What do you do instead?

The opposite! Rather than building a big and tall stack of code, we should try to build a lot of small pieces that we
can compose together in a short stack.

## Small things

Consider the previous process of purchasing a policy. I initially described it as a single process- from being some
anonymous person all the way to being a policyholder. Is that actually the case, though?

Earlier, we broke out some core ideas from the become-a-policyholder process: profiles, reports, test drive, rates,
quotes, and policies. When we initially talked about it, each thing built on top of each other.

But what if they didn't? What if they were distinct, separate small pieces of functionality? The profiles piece might
know how to store the profile information and provide that to anything that might need it. The reports piece might know
how to run external reports and persist them. And so on for the other pieces.

On their own, these smaller pieces are all pretty meaningless from a business perspective. You could almost go as far as
thinking of them as third-party services or libraries if you wanted to.

## Composition and Orchestration

By itself, the "many small things" idea doesn't _quite_ work, though, since there isn't a great way to define a whole
business process as many small things (it's a little contradictory if you think about it).

At some point, we'll need to take these small things, put some business logic around them, and define a more
medium-sized thing that provides some business value. You could imagine having multiple thin orchestration layers on top
of those small pieces.

In the earlier become-a-policyholder process, all of the logic was in one place and joined together. In a world of many
small things with thin orchestration layers on top, we might have a few distinct layers that all live independently of
one another: sign up, get a quote, collect driving data, and purchase a policy.

Each of these pieces might rely on some parts within the other, but the important part to note is that they don't rely
on everything. This distinction saves us from a number of the pitfalls I mentioned earlier.

Because we've already broken up a lot of our functionality into smaller pieces, these medium-sized business processes
that better define the stages of the business can now compose those smaller pieces into something that provides value.
And even better, if we want a new product variant it's as simple as composing those pieces in a different way.

# What does this look like in practice?

At Root, we currently have two variants of car insurance. We'll call them "drive-first" and "drive-later." They are
more-or-less what they sound like. In drive-first, you'll download our app, sign up, take a test drive, get a quote once
that is done, and finally purchase a policy. In drive-later, the test drive step is _after_ you purchase the policy-
you'll start out with a policy and take a thirty-day test drive while already a policyholder. After that, you'll get a
final price based on your driving.

With this alone, you might be able to spot the sticking point of our existing one-big-tall-thing process of becoming a
policyholder: completing your test drive is required to get your rate, which is required to get a quote, which is
required to purchase a policy! Let's take a look at some code, to get a better idea of how this looks and feels:

```ruby
module PolicyService
  def self.purchase(account:, quote:)
    pay_for!(quote: quote)
    create_policy_for!(account: account, quote: quote)
  end
end

module QuoteService
  def self.quote!(account:, rate:, selections:)
    verify_coverage_selections!(selections: selections)
    generate_quote_for!(
      account: account,
      rate: rate,
      selections: selections
    )
  end
end

module RateService
  def self.rate!(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    rating_data = build_rating_data(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = calculate_premiums!(rating_data: rating_data)

    create_rate!(account: account, premiums: premiums)
  end
end

# etc.
```

In this example, the `PolicyService` and `QuoteService` are pretty straightforward, or at least they look that way.
Behind the scenes though, there is a subtle dependency chain that we discussed earlier. Because of that, testing will be
pretty cumbersone. To test purchasing a policy, for example, we need a quote which means we need: a rate, driving data,
reports, and a profile. The primary culprit here is the `RateService`, but let's see why that is.

```ruby {3-4,6-10}
module RateService
  def self.rate!(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    rating_data = build_rating_data(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = calculate_premiums!(rating_data: rating_data)

    create_rate!(account: account, premiums: premiums)
  end
end
```

Since it has hard-coded dependencies on a profile, the reports, and the driving data, we are locked into those
requirements _anywhere that needs a `Rate`_ since that service is _the thing that creates rates_.

So the real question here is "does having many small things solve these issues and allow us to support drive-later?" I'm
pretty convinced that it does and that we'll have some pretty big architectural wins from this.

Since code speaks at a much higher volume that my words can, let's try applying the many-small-things ideas to the
examples we have so far. Since the `RateService` is giving us a lot of trouble and preventing us from building
drive-later, we can start there.

```ruby
module RateService
  def self.calculate_premiums!(rating_data:)
    # super-secret premium calculation code here
  end

  def self.create_rate!(account:, premiums:)
    Rate.create!(account: account, premiums: premiums)
  end
end
```

So, what stands out here? For one, it is clearly a lot smaller than the our old version. All I've really done here is
remove the `rate!` method in favor of exposing the previously-private methods that are doing the real work:

```ruby {3,12,14,20,24}
# one big thing
module RateService
  def self.rate!(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    rating_data = build_rating_data(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = calculate_premiums!(rating_data: rating_data)

    create_rate!(account: account, premiums: premiums)
  end
end

# many small things
module RateService
  def self.calculate_premiums!(rating_data:)
    # super-secret premium calculation code here
  end

  def self.create_rate!(account:, premiums:)
    Rate.create!(account: account, premiums: premiums)
  end
end
```

On top of that small piece, we can build a new orchestration service to handle the old drive-first way:

```ruby
module DriveFirstRateService
  def self.rate!(account:, profile:)
    reports = Reports.where(account: account)
    driving_data = DrivingData.where(account: account)

    drive_first_rating_data = DriveFirstRatingData.from(
      profile: profile,
      reports: reports,
      driving_data: driving_data
    )
    premiums = RateService.calculate_premiums!(
      rating_data: drive_first_rating_data
    )

    RateService.create_rate!(account: account, premiums: premiums)
  end
end
```

Finally, we can easily build support for our driver-later variant:

```ruby
module DriveLaterRateService
  def self.rate!(account:, profile:)
    reports = Reports.where(account: account)

    drive_later_rating_data = DriveLaterRatingData.from(
      profile: profile,
      reports: reports
    )
    premiums = RateService.calculate_premiums!(
      rating_data: drive_later_rating_data
    )

    RateService.create_rate!(account: account, premiums: premiums)
  end
end
```
